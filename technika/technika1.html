<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/controls/OrbitControls.js';
        import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/webxr/XRControllerModelFactory.js';

        try {
            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Add floor
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Add cube
            const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.y = 0.5;
            scene.add(cube);

            // Add lights
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 5);
            scene.add(light);

            // Add OrbitControls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0.5, 0);
            controls.update();

            // Interaction logic
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();
            let isDragging = false;

            window.addEventListener('pointerdown', (event) => {
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(cube);

                if (intersects.length > 0) {
                    isDragging = true;
                }
            });

            window.addEventListener('pointermove', (event) => {
                if (isDragging) {
                    pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                    pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

                    raycaster.setFromCamera(pointer, camera);
                    const intersects = raycaster.intersectObject(floor);

                    if (intersects.length > 0) {
                        cube.position.copy(intersects[0].point);
                        cube.position.y = 0.5; // Keep cube above the floor
                    }
                }
            });

            window.addEventListener('pointerup', () => {
                isDragging = false;
            });

            // VR controller setup
            const controller1 = renderer.xr.getController(0);
            const controller2 = renderer.xr.getController(1);
            scene.add(controller1, controller2);

            const controllerModelFactory = new XRControllerModelFactory();
            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            const controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            // Render loop
            function animate() {
                renderer.setAnimationLoop(() => {
                    renderer.render(scene, camera);
                });
            }
            animate();

            // Resize handling
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

        } catch (error) {
            console.error('An error occurred while setting up the 3D scene:', error);
        }
    </script>
</body>
</html>
